int s, t;        //源点和汇点
int cnt;         //边的数量，从0开始编号。
int Head[maxN];  //每一个点最后一条边的编号
int Next[maxM];  //指向对应点的前一条边
int V[maxM];     //每一条边指向的点
int W[maxM];     //每一条边的残量
int Depth[maxN]; //分层图中标记深度

int Dinic()
{
    int Ans = 0; //记录最大流量
    while (bfs())
    {
        while (int d = dfs(s, inf))
            Ans += d;
    }
    return Ans;
}

bool bfs()
{
    queue<int> Q; //定义一个bfs寻找分层图时的队列
    while (!Q.empty())
        Q.pop();
    memset(Depth, 0, sizeof(Depth));
    Depth[s] = 1; //源点深度为1
    Q.push(s);
    do
    {
        int u = Q.front();
        Q.pop();
        for (int i = Head[u]; i != -1; i = Next[i])
            if ((W[i] > 0) && (Depth[V[i]] == 0)) //若该残量不为0，且V[i]还未分配深度，则给其分配深度并放入队列
            {
                Depth[V[i]] = Depth[u] + 1;
                Q.push(V[i]);
            }
    } while (!Q.empty());
    if (Depth[t] == 0) //当汇点的深度不存在时，说明不存在分层图，同时也说明不存在增广路
        return 0;
    return 1;
}

int dfs(int u, int dist) //u是当前节点，dist是当前流量
{
    if (u == t) //当已经到达汇点，直接返回
        return dist;
    for (int i = Head[u]; i != -1; i = Next[i])
    {
        if ((Depth[V[i]] == Depth[u] + 1) && (W[i] != 0)) //注意这里要满足分层图和残量不为0两个条件
        {
            int di = dfs(V[i], min(dist, W[i])); //向下增广
            if (di > 0)                          //若增广成功
            {
                W[i] -= di; //正向边减
                W[i ^ 1] += di;
                反向边加
                return di; //向上传递
            }
        }
    }
    return 0; //否则说明没有增广路，返回0
}